\documentclass[runningheads]{llncs}

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{url}

\begin{document}

\title{DepChain -- A Dependable Blockchain System}
\author{Simão de Melo Rocha Frias Sanguinho\inst{1}\orcidID{102082} \and José
Augusto Alves Pereira\inst{1}\orcidID{103252} \and Guilherme Silvério de
Carvalho Romeiro Leitão\inst{1}\orcidID{99951}}
\authorrunning{S. Sanguinho, J. Pereira, G. Leitão.}
\institute{Instituto Superior Técnico, Lisboa, Portugal}
\maketitle

\begin{abstract}
    This report details the design, implementation and evaluation of DepChain, a
    simplified permissioned blockchain system with high dependability
    guarantees. In Stage 1, the core consensus and Blockchain service were
    developed. Stage 2 expands the system by integrating smart contract
    execution, native cryptocurrency transfers and enhanced Byzantine fault
    tolerance. We present an in-depth analysis of the design choices,
    implementation details (including Solidity smart contracts and Java-based
    blockchain components), potential attack vectors and countermeasures
    implemented to secure the system.

\keywords{blockchain \and byzantine fault tolerance \and consensus \and dependability \and java \and smart contract}
\end{abstract}

\section{Introduction}
This report presents the design and implementation of a Byzantine Fault Tolerant
(BFT) blockchain service, designed to withstand malicious behavior from a subset
of blockchain members and operate reliably in an unstable network environment.
The project was developed in two phases, where the first phase established the
core consensus and blockchain service mechanisms, and the second phase refined
the application by integrating external owned accounts and smart accounts, as
well as smart contract execution and native cryptocurrency transfers, along with
enhanced fault tolerance. 

The report outlines the system architecture, which includes the account,
network, client, blockchain, and consensus layers, and describes how the system
addresses various Byzantine attack scenarios, ensuring safety and liveness under
the assumption of a correct leader.

\section{Blockchain Nodes and Consensus}

\subsection{Network Layer}
The network layer is responsible for managing the communication between any two
processes (nodes or clients) in the system. By replicating authenticated perfect
links, the network layer ensures that messages are guaranteed to be eventually
delivered to the intended recipient, with its integrity and authenticity
preserved. There are three main components in the network layer:
\begin{itemize}
    \item \textbf{Message:} Encapsulates the message content and metadata. Among
    other things, it contains the type field to identify the message type (e.g.,
    READ, STATE, ACK, etc.). A MAC will be used to ensure the message's
    aforementioned security properties. In order to support different
    transactions, where each one has a different execution (like consulting
    balances, editing the blacklist and transferring a coin or token), the
    message contains a \verb|Request Type| field, which indicates the type of
    request being made. Furthermore, there is also a \verb|Reply Value| field
    that contains the value that is being requested, which can either be a Block
    (for transactions) or simply a value (e.g. for balances). TODO:???? Reply
    value 
    \item \textbf{PerfectLink:} Implements the core communication logics,
    including sending, receiving and managing sessions. To simulate the
    unreliable network, UDP sockets are used.
    \item \textbf{Session:} Represents a communication session between two
    processes. The session contains information like the destination process ID,
    address, session key, and counters for tracking sent and acknowledged
    messages. The session key is a symmetric key that is used for signing
    messages (because using the private key for signing every message would be
    too expensive).
\end{itemize}

\subsubsection{Session Establishment}
Before any communication can occur, a session must be established between two
processes. The session establishment process is as follows: a process initiates
a session by sending a START\_SESSION message. Then, the recipient responds with
an ACK\_SESSION message, containing a symmetric session key that is encrypted
using the recipient's public key (thus ensuring confidentiality). Once the
session is established, all subsequent messages are signed and verified using
the session key to ensure authenticity and integrity.

\subsection{Client and Library Layer - TODO: Change this to fit with the new interface}
The system's regular workflow is as follows: a user will issue the transfer
\verb|<other_user>| \verb|amount| command via the client's CLI. The client layer
will delegate the request to the library layer. Then, the library will construct
a CLIENT\_REQUEST message containing the respective transaction, sign it with
its private key to ensure non-repudiation and send it to every process so that
each of them may check it independently. Next, the library will wait for a
CLIENT\_REPLY. Since a non-Byzantine leader is assumed, the client does not need
to wait for a quorum of replies.

There are several available commands that are available to the client:
\begin{itemize}
  \item \textbf{addBlackList:} Usage: \verb|addBlackList <targetAddress>| - Adds
  the specified address to the blacklist.
  \item \textbf{help:} Usage: \verb|help| - Displays the list of available
  commands.
  \item \textbf{transferFrom:} Usage: \verb|transferFrom <senderAddress>
  <targetAddress> <amount>| - Transfers the specified amount from the sender
  address to the target address.
  \item \textbf{getISTBal:} Usage: \verb|getISTBal <targetAddress>| - Retrieves
  the ISTCoin balance of the specified address.
  \item \textbf{isBlackListed:} Usage: \verb|isBlackListed <targetAddress>| -
  Checks if the specified address is blacklisted.
  \item \textbf{approve:} Usage: \verb|approve <targetAddress> <amount>| - The
  command executor approves the specified address to spend a certain amount on
  their behalf.
  \item \textbf{transferDep:} Usage: \verb|transferDep <targetAddress> <amount>|
  - Transfers the specified amount of DepCoin to the specified address.
  \item \textbf{getDepBal:} Usage: \verb|getDepBal <targetAddress>| - Retrieves
  the DepCoin balance of the specified address.
  \item \textbf{allowance:} Usage: \verb|allowance <sourceAddress>
  <spenderAddress>| - Checks the remaining allowance for a spender from a source
  account.
  \item \textbf{removeBlackList:} Usage: \verb|removeBlackList <targetAddress>|
  - Removes the specified address from the blacklist.
  \item \textbf{transferIST:} Usage: \verb|transferIST <targetAddress> <amount>|
  - Transfers the specified amount of ISTCoin to the targetAddress.
\end{itemize}

\subsection{Blockchain Layer}
The blockchain layer represents a node in the permissioned (closed membership)
blockchain network. Each member is responsible for participating in the
consensus protocol, maintaining a local copy of the blockchain as a list of
strings. The system is designed to ensure that all members agree on the state of
the blockchain, even in the presence of faulty nodes, by leveraging a Byzantine
fault-tolerant consensus protocol (Byzantine Read/Write Epoch Consensus). It
also keeps a State object, which stores a sequence of TimestampValuePair objects
that represent the history of that member on a particular instance of consensus.
The blockchain is updated whenever a consensus decision is reached, ensuring
that all non-faulty members have a consistent view of the blockchain.

A message handler loop continuously listens for incoming messages. If a
CLIENT\_REQUEST is received by the leader, it initiates a new consensus instance
to process the request. For consensus-related messages, the member delegates the
message to the current consensus instance for processing.

\subsection{Consensus Layer}
The consensus mechanism is designed to ensure that all non-faulty members of the
distributed system agree on the value to be appended to the blockchain, even in
the presence of Byzantine faults. The consensus protocol is implemented in the
\verb|ConsensusInstance| class and involves multiple phases:

\subsubsection{Consensus Instance}
Each consensus instance keeps track of the current epoch number. The consensus
instance is initiated by the leader (process 1) when it receives a
CLIENT\_REQUEST from a client. The leader coordinates the consensus process,
while other members participate by responding to messages and contributing their
local states.

\subsubsection{Read Phase}
The consensus process begins with the read phase, where the leader broadcasts a
READ message to all members. Each member responds with a STATE message, which
contains its local epoch state, including the most recent write and the writeset
(a list of all writes).

\subsubsection{Collected Phase}
Once the leader has received STATE messages from a quorum of members, it
broadcasts a COLLECTED message to all members. This message contains the
collected states from the quorum's members, allowing each member to
independently determine the value to be written. Members use the collected
states to select the most recent value that appears in the writeset of more than
\( f \) members (where \( f \) is the maximum number of Byzantine faults
tolerated). If no such value exists, the value is unbounded. In this case, the
leader's most recent write is selected as the candidate value.

\subsubsection{Write Phase}
Every process (members and leader) broadcasts a WRITE message to all members
containing the previously determined value. It then waits for a quorum of WRITE
messages with the same value proposed. If this condition is not met or if a
predefined timeout is reached, then the process aborts the consensus instance;
otherwise, it moves on to the next phase.

\subsubsection{Accept Phase}
Every process then broadcasts an ACCEPT message to all members containing the
value that was previously agreed upon. It waits for a quorum of ACCEPT messages
with the same value back. If this condition is not met or if a predefined
timeout is reached, then the process aborts the consensus instance; otherwise,
it epoch-decides the value and commits it to the blockchain.

\subsubsection{Fault Tolerance and Quorum}
The consensus protocol is designed to tolerate up to \( f \) Byzantine faults,
where \( f \) is the maximum number of faulty members allowed in the network. A
quorum is defined as the minimum number of members required to reach agreement,
calculated as \( 2f+1 \). The protocol ensures that all non-faulty members agree
on the same value, even if \( f \) members behave maliciously, fail to respond,
or crash.

\section{Implementation Details}
The system relies on a Public Key Infrastructure (PKI) to ensure the identity of
members. Due to the performance limitations of public key cryptography, the
system derives a shared symmetric key for each session, which is used to sign
the messages. Since confidentiality is not a requirement, the system does not
encrypt the messages.

The client only communicates with the leader process to simplify the system, a
decision that is justified by the assumption that the leader is correct and will
not deviate from the protocol. However, the system is designed to handle
Byzantine behavior, and if the leader behaves maliciously and deviates from the
protocol, the other members are able to detect the misbehavior and abort the
consensus instance.

\subsection{Smart Contract and Blockchain Enhancements}
To extend the capabilities of the basic blockchain, smart contract execution and
native cryptocurrency transfers have been integrated. The smart contract
\verb|ISTCoin.sol| implements the ERC-20 standard, allowing for token transfers
and invoking an access control contract to validate transactions. The contract
is compiled to EVM bytecode and is deployed as part of the genesis block, where
the deployed bytecode and storage data are stored in a JSON file defining the
initial state. An excerpt of this genesis file is as follows:
\begin{verbatim}
{
  "block_hash": "gs912893421bdajGDSTDAS2108EGDSABkDJHFGDSA",
  "previous_block_hash": null,
  "transactions": [],
  "state": {
    "35bac2533f3d72f58b678e4dbb59c11272e7b75c94dabf0a24d1827890ac69af": { 
      "balance": 100000
    },
    "1259fb40b29be1d77a8031d5ee843d281c3f105cfaa2dec04db3711e279825e0": {
      "balance": 200000
    },
    "d98dde5b265c8a68234ffc3460df86bdf411f988a3b9e8c9e8d9b2c01d244376": {
      "balance": 300000
    },
    "986f0f856dc8a43529c8f5a2145ee619c97ed813dc90f2e7a04c099794d9f243": {
      "balance": 50000000,
      "code": "608060405234801561000f575f80fd5b50...",
      "storage": {
        "owner": 5,
        "key2": "value2"
      }
    }
  }
}
\end{verbatim}
This file initializes externally owned accounts (EOAs) with preset balances and
deploys the smart contracts, ensuring that the system starts in a secure,
verifiable state.

In addition, the Java implementation has been extended to support these
functionalities:
\begin{itemize}
    \item \textbf{EOAccount.java:} Models an externally owned account with
    methods to query and modify balances, ensuring non-negative balances and
    encapsulated state modifications.
    \item \textbf{SmartAccount.java:} Handles contract accounts, encapsulating
    smart contract-specific features such as code storage and owner metadata. An
    inner \verb|Storage| class manages key-value pairs, which is critical for
    maintaining contract state.
    \item \textbf{Blockchain.java:} Reads the genesis file and subsequent block
    files from the specified directory, constructs EOAccounts based on public
    keys and state information, initializes the smart contract account by
    extracting the bytecode and storage, and implements methods to create and
    append new blocks based on incoming transactions.
    \item \textbf{AccessControl.java, Block.java, and BlockState.java:} Support
    block construction and execution. \verb|AccessControl.java| encapsulates the
    balance and code attributes used in contract-based access control, while
    \verb|Block.java| and \verb|BlockState.java| ensure that state transitions
    resulting from transaction execution are clearly represented.
\end{itemize}

\subsection{Transaction Execution and Byzantine Tolerance}
Transactions in DepChain include both native DepCoin transfers and smart
contract invocations. The execution process involves:
\begin{enumerate}
    \item Verifying that the initiating account is authorized (via signature
    verification and access control checks).
    \item Executing smart contract code using Hyperledger Besu's EVM
    environment.
    \item Updating the state in a new block while preserving the non-negativity
    invariant of account balances.
\end{enumerate}

To address Byzantine behavior, several countermeasures have been implemented:
\begin{itemize}
    \item \textbf{Key Ownership and Non-repudiation:} By relying on
    public/private key cryptography, the system ensures that only the rightful
    owner of an account can authorize transactions.
    \item \textbf{Access Control in Smart Contracts:} The access control smart
    contract restricts modifications to the blacklist, preventing unauthorized
    transfers.
    \item \textbf{State Integrity:} The genesis file and subsequent block
    persistence provide a verifiable audit trail of all transactions and state
    transitions.
    \item \textbf{Detection of Malicious Behavior:} Through extensive testing,
    the system is shown to withstand various Byzantine attacks, including
    collusion between clients and servers.
\end{itemize}

\section{Testing and Validation - TODO: Add the behaviors we have integrated with this new functionality}
A comprehensive suite of JUnit tests was developed to validate the overall
system. The test cases simulate a range of scenarios that include:
\begin{itemize}
    \item Correct initialization of the blockchain state from the genesis file.
    \item Accurate execution of DepCoin transfers and smart contract
    invocations.
    \item Integrity of the blockchain when faced with Byzantine inputs, such as
    unauthorized transactions or colluding parties.
    \item Persistence and recovery of blockchain state across multiple blocks.
\end{itemize}
These tests verify the dependability guarantees and ensure that the system meets
its design goals under both normal and adversarial conditions.

\section{Discussion and Future Work}
The integration of enhanced smart contract execution and native cryptocurrency
transfers has expanded the DepChain system from a simple blockchain to a
full-fledged platform capable of handling sophisticated transactions and
maintaining a robust audit trail. The design decisions, such as leveraging
Hyperledger Besu's EVM for smart contract execution and using a rigorous genesis
block format, significantly enhance system dependability. Future work could
involve:
\begin{itemize}
    \item Extending the consensus algorithm to support dynamic membership.
    \item Further refining Byzantine detection mechanisms.
    \item Optimizing transaction throughput and state synchronization.
\end{itemize}

\section{Conclusion}
This report presents a detailed overview of DepChain, covering both the core
functionalities and the advanced features integrated into the system. The system
now supports secure DepCoin transfers, smart contract execution, and robust
countermeasures against Byzantine attacks, meeting the high dependability and
security requirements set forth in the project statement.

\bibliographystyle{splncs04}
\begin{thebibliography}{4}
\bibitem{besu}
Hyperledger Besu Ethereum Client.
\url{https://github.com/hyperledger/besu/tree/main}.

\bibitem{erc20}
ERC-20 Token Standard.
\url{https://ethereum.org/en/developers/docs/standards/tokens/erc-20}.

\bibitem{openzeppelin}
OpenZeppelin - ERC20 Implementation.
\url{https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20}.

\bibitem{lncs}
Springer LNCS Guidelines.
\url{https://www.springer.com/gp/computer-science/lncs/conference-proceedings-guidelines}.
\end{thebibliography}

\end{document}
